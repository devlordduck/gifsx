/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Output mode for the image data. */
export const enum ColorOutput {
  /**
   * RGBA color mode, where each pixel is represented with red, green, blue, and alpha components.
   * Suitable for detailed color rendering.
   */
  Rgba = 0,
  /**
   * Indexed pixel mode, where each pixel references a color in a palette.
   * Useful for memory-efficient representations with limited color ranges.
   */
  IndexedPixels = 1
}
/** Disposal method, describing how the next frame should be drawn over the current one. */
export const enum DisposalMethod {
  /** Decoder is not required to take any specific action. */
  Any = 0,
  /** Retain the current frame as it is. */
  Keep = 1,
  /** Clear the frame and restore the canvas to its background color. */
  Background = 2,
  /** Restore the canvas to the previous frame's state. */
  Previous = 3
}
/**
 * Convert RGBA to hex color. (e.g. `rgbaToHex([255, 0, 0, 255, 255, 128, 0, 128])` -> `["#FF0000", "#FF800080"]`)
 * @param rgba - An array of RGBA values.
 * @param alwaysIncludeAlpha - Whether to always include the alpha channel in the output.
 * @param allowShort - Whether to allow short hex output.
 * @returns An array of hex color strings. (e.g. `"#FF0000"`)
 */
export declare function rgbaToHex(rgba: Uint8Array, alwaysIncludeAlpha?: boolean | undefined | null, allowShort?: boolean | undefined | null): Array<string>
/**
 * Convert RGB to hex color. (e.g. `rgbToHex([255, 0, 0, 255, 128, 0])` -> `["#FF0000", "#FF8000"]`)
 * @param rgb - An array of RGB values.
 * @param allowShort - Whether to allow short hex output.
 * @returns An array of hex color strings. (e.g. `"#FF0000"`)
 */
export declare function rgbToHex(rgb: Uint8Array, allowShort?: boolean | undefined | null): Array<string>
/**
 * Convert hex color to RGBA. (e.g. `hexToRgba(["#FF0000FF", "#800080FF"])` -> `[255, 0, 0, 255, 128, 0, 128, 255]`)
 * @param hex - An array of hex color strings.
 * @returns A flattened array of RGBA values.
 */
export declare function hexToRgba(hex: Array<string>): Uint8Array
/**
 * Convert hex color to RGB. (e.g. `hexToRgb(["#FF0000", "#FF8000"])` -> `[255, 0, 0, 255, 128, 0]`)
 * @param hex - An array of hex color strings.
 * @returns A flattened array of RGB values.
 */
export declare function hexToRgb(hex: Array<string>): Uint8Array
export declare function indexedToRgba(pixels: Uint8Array, palette: Uint8Array, transparent?: number | undefined | null): Uint8Array
export declare function indexedToHex(pixels: Uint8Array, palette: Uint8Array, transparent?: number | undefined | null, alwaysIncludeAlpha?: boolean | undefined | null, allowShort?: boolean | undefined | null): Array<string>
/** A GIF frame. */
export declare class Frame {
  /** The delay for this frame in units of 10ms (e.g., a value of `10` equals 100ms). */
  delay: number
  /** How the current frame should be disposed of when moving to the next one. */
  dispose: DisposalMethod
  /** An optional index of a transparent color in the palette. */
  transparent?: number
  /** Indicates whether this frame requires user input to proceed. */
  needsUserInput: boolean
  /** The vertical offset of the frame relative to the top of the canvas. */
  top: number
  /** The horizontal offset of the frame relative to the left of the canvas. */
  left: number
  /** Width of the frame. */
  width: number
  /** Height of the frame. */
  height: number
  /** True if the image is interlaced. */
  interlaced: boolean
  /** The frame's palette. */
  get palette(): Buffer | null
  /** Sets the frame's palette. */
  setPalette(val?: Uint8Array | undefined | null): void
  /** The buffer of this frame. */
  get buffer(): Buffer
  setBuffer(val: Uint8Array): void
  /**
   * Creates a frame from RGBA pixel data.
   *
   * ### Notes:
   * - Speed needs to be in the range 1-30. Higher is faster, lower CPU usage but worse quality.
   * - The size of `buffer` should match the expected size based on `width`, `height`.
   */
  static fromRgba(width: number, height: number, buffer: Uint8Array, speed?: number | undefined | null): Frame
  /**
   * Creates a frame from RGB pixel data.
   *
   * ### Notes:
   * - Speed needs to be in the range 1-30. Higher is faster, lower CPU usage but worse quality.
   * - The size of `buffer` should match the expected size based on `width`, `height`.
   */
  static fromRgb(width: number, height: number, buffer: Uint8Array, speed?: number | undefined | null): Frame
  /**
   * Creates a frame from hex pixel data.
   *
   * ### Notes:
   * - Speed needs to be in the range 1-30. Higher is faster, lower CPU usage but worse quality.
   * - The size of `buffer` should match the expected size based on `width`, `height`.
   * - The color output will be in Rgba.
   */
  static fromHex(width: number, height: number, buffer: Array<string>, speed?: number | undefined | null): Frame
  /**
   * Creates a frame from indexed pixel data.
   *
   * ### Notes:
   * - The size of `buffer` should match the expected size based on `width`, `height`.
   */
  static fromIndexedPixels(width: number, height: number, pixels: Uint8Array, palette?: Uint8Array | undefined | null, transparent?: number | undefined | null): Frame
}
export declare class Encoder {
  /** The gif width. */
  readonly width: number
  /** The gif height. */
  readonly height: number
  /** Create a new encoder. */
  constructor(width: number, height: number, palette?: Uint8Array | undefined | null)
  /**
   * Add a frame to the gif.
   *
   * ### Notes:
   * - The size of `buffer` should match the expected size based on `width`, `height`.
   */
  addFrame(frame: Frame): void
  /** The global color palette. */
  get palette(): Uint8Array | null
  /** Sets the repeat count for the gif. If the value is -1, the gif will repeat infinitely; otherwise, the gif will repeat a `value` number of times. */
  setRepeat(value: number): void
  /** Returns the gif buffer. */
  getBuffer(): Uint8Array
}
/** The GIF Decoder. */
export declare class Decoder {
  /**
   * Create a new decoder.
   * @param buffer - The GIF buffer to decode.
   * @param options - The options to use for decoding.
   */
  constructor(buffer: Uint8Array, options?: DecodeOptions | undefined | null)
  /** Returns the next frame info. (skips the buffer) */
  nextFrameInfo(): Frame | null
  /**
   * Reads the next frame from the GIF.
   * Do not call `<Decoder>.nextFrameInfo` beforehand. Deinterlaces the result.
   */
  readNextFrame(): Frame | null
  /** Output buffer size. */
  get bufferSize(): number
  /** Line length of the current frame. */
  get lineLength(): number
  /** The color palette relevant for the frame that has been decoded. */
  get palette(): Uint8Array
  /** The global color palette. */
  get globalPalette(): Uint8Array | null
  /** Width of the GIF. */
  get width(): number
  /** Height of the GIF. */
  get height(): number
  /**
   * Index of the background color in the global palette
   * In practice this is not used, and the background is always transparent
   */
  get bgColor(): number | null
  /** Number of loop repetitions. */
  get loops(): number
}
/** Options for opening a GIF decoder. `<DecodeOptions>.readInfo` will create a decoder with these options. */
export declare class DecodeOptions {
  /** Create new decode options. */
  constructor()
  /** Configure how color data is decoded. */
  setColorOutput(value: ColorOutput): void
  /**
   * Configure a memory limit for decoding.
   * @param value - The memory limit in bytes. Negative values are treated as unlimited. (e.g. -1)
   * If the provided value is `-1`, the memory limit is set to unlimited. If a positive integer is provided,
   * the memory limit will be set in bytes. A non-zero integer is required for this case, and any non-integer or
   * invalid value will return an error.
   */
  setMemoryLimit(value: number): void
  /**
   * Configure if frames must be within the screen descriptor.
   * @param value - Whether to check frame consistency.
   * The default is `false`.
   * When turned on, all frame descriptors being read must fit within the screen descriptor or otherwise an error is returned and the stream left in an unspecified state.
   * When turned off, frames may be arbitrarily larger or offset in relation to the screen. Many other decoder libraries handle this in highly divergent ways. This moves all checks to the caller, for example to emulate a specific style.
   */
  checkFrameConsistency(value: boolean): void
  /**
   * Configure whether to skip decoding frames.
   * @param value - Whether to skip frame decoding.
   * The default is `false`.
   * When turned on, LZW decoding is skipped. `<Decoder>.readNextFrame` will return compressed LZW bytes in frame’s data. `<Decoder>.nextFrameInfo` will return the metadata of the next frame as usual. This is useful to count frames without incurring the overhead of decoding.
   */
  skipFrameDecoding(value: boolean): void
  /**
   * Configure if LZW encoded blocks must end with a marker end code.
   * @param value - Whether to check for the end code.
   * The default is `false`.
   * When turned on, all image data blocks—which are LZW encoded—must contain a special bit sequence signalling the end of the data. LZW processing terminates when this code is encountered. The specification states that it must be the last code output by the encoder for an image.
   * When turned off then image data blocks can simply end. Note that this might silently ignore some bits of the last or second to last byte.
   */
  checkLzwEndCode(value: boolean): void
  /**
   * Configure if unknown blocks are allowed to be decoded.
   * @param value - Whether to allow unknown blocks.
   * The default is `false`.
   * When turned on, the decoder will allow unknown blocks to be in the `BlockStart` position.
   * When turned off, decoded block starts must mark an `Image`, `Extension`, or `Trailer` block. Otherwise, the decoded image will return an error. If an unknown block error is returned from decoding, enabling this setting may allow for a further state of decoding on the next attempt.
   */
  allowUnknownBlocks(value: boolean): void
  /**
   * Reads the logical screen descriptor including the global color palette
   * Returns a Decoder. All decoder configuration has to be done beforehand.
   * @param buffer - The GIF buffer to decode.
   */
  readInfo(buffer: Uint8Array): Decoder
}
/** A NeuQuant instance. */
export declare class NeuQuant {
  /** Create a new NeuQuant instance. */
  constructor(sampleFactor: number, maxColors: number, pixels: Uint8Array)
  /** Maps the rgba-pixel in-place to the best-matching color in the color map. */
  mapPixel(pixel: Uint8Array): void
  /**
   * Finds the best-matching index in the color map.
   * `pixel` is assumed to be in RGBA format.
   */
  indexOf(pixel: Uint8Array): number
  /** Lookup pixel values for color at `idx` in the colormap. */
  lookup(idx: number): Uint8Array | null
  /** Returns the RGBA color map calculated from the sample. */
  colorMapRgba(): Uint8Array
  /** Returns the RGB color map calculated from the sample. */
  colorMapRgb(): Uint8Array
}
